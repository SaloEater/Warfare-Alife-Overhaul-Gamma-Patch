-- werejew

-- This file is used to analyze levels. In the previous version of warfare, level analysis was relatively messy.


--[[

	Factions will calculate a risk associated with levels, which will be based on how many enemy bases are present, and if their current level
	is a higher priority level for any enemy faction on neighboring levels.
	
	level_information[level].faction_stats[faction] = {
		target_level = #,
		base_count = #,
		territory_count = #,
		resource_count = #,
		linked_resource_count = #,
		total_power = #,
		faction_war = bool,
		inactive_count, -- current_action == 1
		active_count, -- current_action == 0
		
		-- the following likely isn't necessary		
		offense_squads, -- current_action = 0 and (target.props.base > 0 or target.props.resource > 0)
		patrol_squads, 	-- current_action = 0 and (target.props.base == 0 and target.props.resource == 0)
	}
	
	level_information[level].levels_by_distance = {}
	level_information[level].faction_count = #
	level_information[level].smarts = {}
	level_information[level].base_count = #
	level_information[level].territory_count = #
	level_information[level].resource_count = #
	level_information[level].lair_count = #
	level_information[level].first_update = true

]]
printd = warfare.printd

level_timers = {}
level_information = {}

function update()
	printf("Updating levels...")
	for i,lvl in pairs(level_targets.active_levels) do
		update_level(lvl)
	end
	printf("Levels updated.")
end

-- setup the faction table within level_information[level_id]["faction_stats"] and add one to the faction count
function setup_faction_table(lvl, faction)
	if (faction ~= "none") then
		level_information[lvl].faction_count = level_information[lvl].faction_count + 1
	end

	level_information[lvl].faction_stats[faction] = {
		base_count = 0,
		territory_count = 0,
		resource_count = 0,
		linked_resource_count = 0,
		total_power = 0,
		inactive_count = 0,
		active_count = 0,
	}
end

-- will be used by factions to determine whether or not they should find a new level to target
function faction_enemy_present(lvl, faction)
    printd(0)
	if (faction == "none") then
		return 0, {}
	end

	local enemyCount = 0
	local enemies = {}

	for f,tbl in pairs(level_information[lvl].faction_stats) do
		if (faction ~= f) then
			if (game_relations.is_factions_enemies(faction, f)) then
				enemyCount = enemyCount + 1
				enemies[f] = true
			end
		end
	end

    printd(1)
	
	return enemyCount, enemies
end

-- Updates information for the specified level.
function update_level(lvl)
	printf("Updating level %s...", alife():level_name(lvl))
	if (not level_timers[lvl] or game.get_game_time():diffSec(level_timers[lvl]) >= (level_information[lvl].next_update*60)) then
		printf("Line 1: Checking if level needs update")
		printd(0)
		printf("Line 2: Called printd(0)")

		level_timers[lvl] = game.get_game_time()
		printf("Line 3: Set level_timers[%s] to current game time", lvl)

		level_information[lvl].next_update = math.random(5, 20)
		printf("Line 4: Set next_update to random value: %s", level_information[lvl].next_update)

		level_information[lvl].faction_stats = {}
		printf("Line 5: Cleared faction_stats table")

		level_information[lvl].faction_count = 0
		printf("Line 6: Reset faction_count to 0")

		level_information[lvl].faction_war = false
		printf("Line 7: Set faction_war to false")

		setup_faction_table(lvl, "none")
		printf("Line 8: Set up 'none' faction table")

		for i,sm in pairs(level_information[lvl].smarts) do
			printf("Line 9: Processing smart %s", sm)
			local smart = sm and alife_object(sm)
			printf("Line 10: Got smart object: %s", smart and smart.id or "nil")

			if (smart and smart.owning_faction) then
				printf("Line 11: Smart has owning faction: %s", smart.owning_faction)
				if not (level_information[lvl].faction_stats[smart.owning_faction]) then
					printf("Line 12: Faction not in stats yet, setting up table")
					setup_faction_table(lvl, smart.owning_faction)
					printf("Line 13: Faction table set up")
				end

				if (smart.props.base > 0) then
					printf("Line 14: Smart is a base")
					level_information[lvl].faction_stats[smart.owning_faction].base_count = level_information[lvl].faction_stats[smart.owning_faction].base_count + 1
					printf("Line 15: Incremented base_count to %s", level_information[lvl].faction_stats[smart.owning_faction].base_count)
					level_information[lvl].faction_stats[smart.owning_faction].total_power = level_information[lvl].faction_stats[smart.owning_faction].total_power + smart.defense_power
					printf("Line 16: Incremented total_power to %s", level_information[lvl].faction_stats[smart.owning_faction].total_power)
				elseif (smart.props.territory > 0) then
					printf("Line 17: Smart is a territory")
					level_information[lvl].faction_stats[smart.owning_faction].territory_count = level_information[lvl].faction_stats[smart.owning_faction].territory_count + 1
					printf("Line 18: Incremented territory_count to %s", level_information[lvl].faction_stats[smart.owning_faction].territory_count)
					level_information[lvl].faction_stats[smart.owning_faction].total_power = level_information[lvl].faction_stats[smart.owning_faction].total_power + smart.defense_power
					printf("Line 19: Incremented total_power to %s", level_information[lvl].faction_stats[smart.owning_faction].total_power)
				end

				if (smart.props.resource > 0) then
					printf("Line 20: Smart has resources")
					level_information[lvl].faction_stats[smart.owning_faction].resource_count = level_information[lvl].faction_stats[smart.owning_faction].resource_count + 1
					printf("Line 21: Incremented resource_count to %s", level_information[lvl].faction_stats[smart.owning_faction].resource_count)
					level_information[lvl].faction_stats[smart.owning_faction].total_power = level_information[lvl].faction_stats[smart.owning_faction].total_power + smart.defense_power
					printf("Line 22: Incremented total_power to %s", level_information[lvl].faction_stats[smart.owning_faction].total_power)
				end
			end
			printf("Line 23: Finished processing smart %s", sm)
		end
		printf("Line 24: Finished processing all smarts")

		if level_information[lvl].first_update then
			printf("Line 25: This is first update for level")
			level_information[lvl].first_update = false
			printf("Line 26: Set first_update to false")

			level_information[lvl].next_update = 0
			printf("Line 27: Set next_update to 0")

			printd(1)
			printf("Line 28: Called printd(1)")
			return
		end
		printf("Line 29: Not first update, continuing")

		for f,tbl in pairs(level_information[lvl].faction_stats) do
			printf("Line 30: Processing faction %s", f)
			if f ~= "none" then
				printf("Line 31: Faction is not 'none'")
				for lvl2,_ in pairs(level_targets.level_links[lvl]) do
					printf("Line 32: Checking linked level %s", lvl2)
					if (level_information[lvl2] and level_information[lvl2].faction_stats[f]) then
						printf("Line 33: Level has faction stats for %s", f)
						level_information[lvl].faction_stats[f].linked_resource_count = level_information[lvl].faction_stats[f].linked_resource_count + level_information[lvl2].faction_stats[f].resource_count
						printf("Line 34: Added %s to linked_resource_count, now %s", level_information[lvl2].faction_stats[f].resource_count, level_information[lvl].faction_stats[f].linked_resource_count)
					end
					printf("Line 35: Finished checking level %s", lvl2)
				end
				printf("Line 36: Finished checking linked levels")

				if level_information[lvl].faction_count == 1 then
					printf("Line 37: Only one faction in level")
					level_information[lvl].faction_stats[f].faction_war = false
					printf("Line 38: Set faction_war to false")
				else
					printf("Line 39: Multiple factions in level")
					local enemyCount, enemies = faction_enemy_present(lvl, f)
					printf("Line 40: Enemy count: %s", enemyCount)
					level_information[lvl].faction_stats[f].faction_war = (enemyCount > 0)
					printf("Line 41: Set faction_war to %s", level_information[lvl].faction_stats[f].faction_war)
				end
			end
			printf("Line 42: Finished processing faction %s", f)
		end
		printf("Line 43: Finished processing all factions")

		if (level_information[lvl].base_count > 0) then
			printf("Line 44: Level has bases (%s)", level_information[lvl].base_count)
			for f,tbl in pairs(level_information[lvl].faction_stats) do
				printf("Line 45: Checking faction %s for targeting", f)
				if f ~= "none" then
					printf("Line 46: Faction is not 'none'")
					if not (level_information[lvl].faction_stats[f].faction_war or level_information[lvl].faction_stats["none"].base_count > 0) then
						printf("Line 47: No faction war and no empty bases")
						local aggression = warfare_options.options.factions[f].expansion_aggression
						printf("Line 48: Faction aggression: %s", aggression)

						if ((pda_actor.manual_control and f ~= warfare.actor_faction) or (not pda_actor.manual_control)) then
							printf("Line 49: Faction eligible for expansion check")
							if (math.random(0, 100) < aggression) then
								printf("Line 50: Random check passed, finding target")
								local target = get_level_target(lvl, f)
								printf("Line 51: Target level: %s", target or "nil")
								level_information[lvl].faction_stats[f].target_level = target
								printf("Line 52: Set target_level to %s", target or "nil")
							else
								printf("Line 53: Random check failed, not targeting")
							end
						else
							printf("Line 54: Faction not eligible for expansion check")
						end
					else
						printf("Line 55: Faction already in war or empty bases available")
					end
				end
				printf("Line 56: Finished checking faction %s for targeting", f)
			end
			printf("Line 57: Finished checking all factions for targeting")
		else
			printf("Line 58: Level has no bases")
		end

		for f,tbl in pairs(level_information[lvl].faction_stats) do
			printf("Line 59: Processing faction %s for debug info", f)
			local bc = tbl.base_count
			printf("Line 60: base_count = %s", bc)
			local tc = tbl.territory_count
			printf("Line 61: territory_count = %s", tc)
			local rc = tbl.resource_count
			printf("Line 62: resource_count = %s", rc)
			local tp = tbl.total_power
			printf("Line 63: total_power = %s", tp)
			local fw = tbl.faction_war
			printf("Line 64: faction_war = %s", tostring(fw))
			local ac = tbl.active_count
			printf("Line 65: active_count = %s", ac)
			local ic = tbl.inactive_count
			printf("Line 66: inactive_count = %s", ic)
			printf("Line 67: Finished processing faction %s for debug info", f)
		end
		printf("Line 68: Finished processing all factions for debug info")
	end
	printf("Line 69: End of if block")

	printd(2)
	printf("Line 70: Called printd(2)")
end

-- This function will also take into consideration calculated hostility.
-- calculated hostility will be high if enemy faction is targeting, medium if enemy faction has bases on the level (maybe consider total bases / bases owned), and low if no hostile factions.
-- That should allow for relatively decent targeting of levels.
-- Likely still want to use linked levels and run the above function on them. If no valid invasion target found, then go ahead and calculate for every level.


--[[

This function is used to calculate level target priorities for factions, which will be used when finding an invasion target. Levels will find their own targets independently if they have
no enemies on their current level.

TODO: assign point values based on the following criteria; smart terrains should operate in a similar manner as well in order to have uniformity in target selection

* are the levels linked
* is the target level targeting this level (consider not taking this into account so squads can build up in low priority smart terrains to take their first base on target level)
* distance
* is the target level targeting a friendly level
* target level hostility (enemy base count; if another friendly level is targeting or being targeted, consider its base count; consider own levels base count as well)
* faction priority
* target level power (enemy total power; if another level is targeting or being targeted, consider its total power; consider own total power as well)
* target level resource count
* is a faction war in progress on target level

]]

function get_level_target(lvl, faction)
    printd(0)
	local links = level_targets.level_links[lvl]
	local levels = level_targets.active_levels
	local dists = {}
	
	local a = level_targets.level_offsets[lvl]
	
	for i,lvl2 in pairs(levels) do
		if lvl ~= lvl2 and level_information[lvl2].faction_stats then
			local b = level_targets.level_offsets[lvl2]
			local dist = math.pow(b[1] - a[1], 2) + math.pow(b[2] - a[2], 2) + math.pow(b[3] - a[3], 2)
			local priority = 1
			
			-- linked levels get significantly more priority
			if links[lvl2] then
				priority = priority + 50
			end
			
			local enemyCount, enemies = faction_enemy_present(lvl2, faction)
			
			-- Enemies are present. Calculate how many bases they own vs total number of bases.
			if enemyCount > 0 then
			
				-- Iterate through enemies; for each enemy base present, increase priority by 2
				for f,v in pairs(enemies) do	
					local presence = level_information[lvl2].faction_stats[f].base_count	
					priority = priority + 2
				end
			end
			
			-- Factor in total level priority, which is the sum total of individual smart terrain priority for the faction
			if level_information[lvl2].faction_priority[faction] then
				priority = priority + level_information[lvl2].faction_priority[faction]
			end
			
			-- Only consider levels with enemies or empty bases, as otherwise you'd be targeting neutral or allied factions.
			if (enemyCount > 0 or level_information[lvl2].faction_stats["none"].base_count > 0) then
				dists[#dists+1] = { lvl2, dist, priority, (dist/priority) }
			end
		end
	end
	
	function level_sort(a, b)
		return a[4] < b[4]
	end
	
	table.sort(dists, level_sort)
	
	--printf("Priorities for " .. game.translate_string(faction) .. " at level " .. alife():level_name(lvl))
	
	for i,t in pairs(dists) do
		--printf(game.translate_string(alife():level_name(t[1])) .. " - dist: " .. t[2] .. " priority: " .. t[3] .. " dist/priority: " .. t[4])
	end
    
    printd(1)
		
	-- Return highest priority level target.
	return dists[1] and dists[1][1]
end